
#include <stdio.h>
#include <string.h>
#include <omnetpp.h>
#include <queue>
#include "message_m.h"
#include "simplehost.h"
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;
using namespace omnetpp;

map<int, int> pariSourceDes;
vector<int> sources;

int *recvMsgCountSum = nullptr;

Define_Module(SimpleHost);


void SimpleHost::initialize()
{
    MSG_GEN_INTERVAL = getParentModule()->par("MSG_GEN_INTERVAL");
    SIMULATOR_TIME = getParentModule()->par("SIMULATOR_TIME");
    EXB_SIZE = getParentModule()->par("EXB_SIZE");
    count = EXB_SIZE;
    k = getParentModule()->par("k");

    INTERVAL_TIME = getParentModule()->par("INTERVAL");

    receivedMsgCountLength = SIMULATOR_TIME / INTERVAL_TIME;
    receivedMsgCount = new int[receivedMsgCountLength];

    memset(receivedMsgCount, 0, receivedMsgCountLength * sizeof(int));
    if (recvMsgCountSum == nullptr) {
        recvMsgCountSum = new int[receivedMsgCountLength];
    }
    memset(recvMsgCountSum, 0, receivedMsgCountLength * sizeof(int));

    scheduleAt(0, new cMessage("nextInterval"));

    scheduleAt(0, new cMessage("generate"));

    scheduleAt(0, new cMessage("send"));

    int k = getParentModule()->par("k");
    // init random pair

    if(getId() - 2 == 0){
            std::vector<int> hosts;
            srand(time(0));
            int numEachPod = k * k / 4 + k;
            for (int p = 0; p < k; p++) {
                int offset = numEachPod * p;

                for (int e = 0; e < k / 2; e++) {
                    for (int s = 0; s < k / 2; s++) {
                        int server = offset + e * k / 2 + s;
                        hosts.push_back(server);
                    }
                }
            }

            std::random_shuffle(hosts.begin(), hosts.end());

            while(hosts.size()>0){

                int src = hosts[hosts.size()-1];
                int des = hosts[hosts.size()-2];

                EV << src << " " << des << endl;
                pariSourceDes.insert(std::pair<int, int>(src, des));
                sources.push_back(src);
                hosts.pop_back();
                hosts.pop_back();
                std::cout << "\n";
                std::random_shuffle(hosts.begin(), hosts.end());
            }
    }

}

void SimpleHost::handleMessage(cMessage *msg)
{

    if (simTime() >= SIMULATOR_TIME){
        delete(msg);
        return;
    }

    if(std::find(sources.begin(), sources.end(), getId() - 2) != sources.end()) {
        // if sending Hosts

            if (strcmp(msg->getName(), "generate") == 0) {

                    sourceQueue.push(++lastMsgId);
                    EV<< "Message generated by Host" << endl;
                    scheduleAt(simTime() + MSG_GEN_INTERVAL, msg);

                    if (exitBuffer.size() < EXB_SIZE) {
                        SQtoEXB();
                    }

                    //cout << "In Generate: count: "<< count << endl;


            }
            if (strcmp(msg->getName(), "send") == 0) {
                    if(count > 0){
                        sendMsg();
                        SQtoEXB();
                    }

                    scheduleAt(simTime() + CHANNEL_DELAY, msg);
            }
    } else {
        // if receiver Hosts

                char temp[15];
                strncpy(temp, msg->getName(), 11);
                temp[11] = 0;

                if (strcmp(temp, "MsgFromHost") == 0) {
                            EV << "Received Msg from Host" << endl;

                            countMsg++;
                            receivedMsgCount[intervalIndex]++;
                            delete(msg);
                }

                if (strcmp(msg->getName(), "nextInterval") == 0) {
                     recvMsgCountSum[intervalIndex] += receivedMsgCount[intervalIndex];
                     intervalIndex++;
                     scheduleAt(simTime() + INTERVAL_TIME, msg);
                }
    }



}

void SimpleHost::SQtoEXB ()
{
    if (!sourceQueue.empty()){
            int msgId = sourceQueue.front();
            sourceQueue.pop();
            exitBuffer.push(msgId);

    }
}

void SimpleHost::sendMsg(){
    if (!exitBuffer.empty()) {

        int sentMsgId = exitBuffer.front();
        exitBuffer.pop();

        //to make diffrent name of message, cause when you delete mess in Des, don't delete all mess
        char name[50];
        sprintf(name, "MsgFromHost%d", sentMsgId);

        MessageMakeByHost *sentMsg = new MessageMakeByHost(name);
        sentMsg->setId(sentMsgId);
        sentMsg->setSource(getId()-2);
        sentMsg->setDestination(pariSourceDes[getId()-2]);
        sentMsg->setPreviosNodeIndex(getId()-2);
        sentMsg->setBitLength(100000);
        //send(sentMsg, "out");
        send(sentMsg, "gate$o", 0);

        count--;
    }
}
void SimpleHost::incNumSpacesOfNextENB(){
    count++;
}

void SimpleHost::finish(){
    if(std::find(sources.begin(), sources.end(), getId() - 2) == sources.end()){

            EV<<"Host "<<getId() - 2 << " : countMsg = " << countMsg << endl;
            //EV<<"-----------------------------------------------------"<<endl;
    }

    if (getId() - 2 == 0) {
        FILE *fp;
        FILE *fp2;

        fp = fopen("./Resulttest.txt", "w");
        fp2 = fopen("./ResultThroughputtest.txt", "w");
        for (int i = 0; i < receivedMsgCountLength; i++) {
             fprintf(fp, "%d ", recvMsgCountSum[i]);
             fprintf(fp2, "%0.2f ", 1.0*recvMsgCountSum[i]*(100000.0/1000000000)*100/(k*k*k/8)/INTERVAL_TIME);
        }
        fclose(fp);
        fclose(fp2);
   }


}


